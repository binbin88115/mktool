# -*- coding: utf-8 -*-
# cocos2dx在android机上的编译是需要makefile文件的，而本工具提供一鍵生成makefile文件。
#
# 

import sys
import os

reload(sys)
sys.setdefaultencoding('utf8')

WRITE_PATH_INDEX = 1
WRITE_FILE_NAME = 'mkfile.mk'

MY_SRC_FILES_VAR = 'MY_SRC_FILES'
MY_SRC_DIRS_VAR = 'MY_SRC_DIRS'
LOCAL_PATH_VAR = 'LOCAL_PATH'

class MakefileTool:

	_write_path = None
	_file_list = None
	_directory_list = None

	def __init__(self):
		self._try_get_write_path()
		self._parse_file_list()
		self._parse_directory_list()

	def _parse_file_list(self):
		info = os.path.split(self._write_path)
		self._file_list = str.format('{} := \\\r\n', MY_SRC_FILES_VAR)
		self._file_list += self._get_file_list(self._write_path, info[0])

	def _parse_directory_list(self):
		info = os.path.split(self._write_path)
		self._directory_list = str.format('{} := \\\r\n', MY_SRC_DIRS_VAR)
		self._directory_list += self._get_directory_list(self._write_path, info[0])

	def _get_file_list(self, path, truncate_path):
		text = ''
		list_dir = os.listdir(path)
		list_dir.sort()
		for name in list_dir:
			file_path = os.path.join(path, name)
			if self._is_c_file(file_path) or self._is_cpp_file(file_path):
				text += str.format('  ../../{} \\\r\n', file_path[len(truncate_path)+1:])
			elif os.path.isdir(file_path):
				text += self._get_file_list(file_path, truncate_path)
		return text

	def _get_directory_list(self, path, truncate_path):
		text = str.format('  $({})/../../{} \\\r\n', LOCAL_PATH_VAR, path[len(truncate_path)+1:])
		list_dir = os.listdir(path)
		list_dir.sort()
		for name in list_dir:
			directory_path = os.path.join(path, name)
			if os.path.isdir(directory_path):
				sub_text = self._get_directory_list(directory_path, truncate_path)
				if len(sub_text) > 0:
					text += sub_text
		return text

	def _is_c_file(self, file_name):
		if os.path.isfile(file_name):
			indexof = file_name.rfind('.')
			if indexof != -1:
				if file_name[indexof:] == '.c':
					return True
			return False
		else:
			return False

	def _is_cpp_file(self, file_name):
		if os.path.isfile(file_name):
			indexof = file_name.rfind('.')
			if indexof != -1:
				file_ext = file_name[indexof:]
				if file_ext == '.cpp' or file_ext == '.cc':
					return True
			return False
		else:
			return False

	def _try_get_write_path(self):
		try:
			write_path = sys.argv[WRITE_PATH_INDEX]
			write_path = os.path.abspath(write_path)
			if os.path.exists(write_path):
				self._write_path = write_path
			else:
				self._error('指定C/C++代码的存放路径错误')
				sys.exit()
		except Exception:
			self._error('没有指定C/C++代码的存放路径')
			sys.exit()

	def _write_mk(self, text):
		path = os.path.join(self._write_path, WRITE_FILE_NAME)
		f = file(path, 'w')
		f.write(text)
		f.close()

	def _error(self, error_msg):
		self._print_utf8(str.format('ERROR：{}', error_msg))

	def _print_utf8(self, content):
		print content.decode('utf-8')

	def exportMakeFile(self):
		text = "# THIS FILE IS GENERATED BY TOOL, PLEASE DONT'T EDIT \r\n\r\n"
		text += str.format('{} := $(call my-dir)\r\n\r\n', LOCAL_PATH_VAR)
		text += str.format('{}\r\n', self._file_list)
		text += self._directory_list
		self._write_mk(text)

if __name__ == '__main__':
	tool = MakefileTool()
	tool.exportMakeFile()